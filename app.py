from flask import Flask, request, jsonify
from flask_cors import CORS
import psycopg2
from psycopg2.extras import RealDictCursor
import os
import google.generativeai as genai
from datetime import datetime

app = Flask(__name__)
CORS(app)

# --- CONFIGURATION ---
raw_db_url = os.environ.get("DATABASE_URL")

# FIX: Auto-correct 'postgres://' to 'postgresql://' for Render
if raw_db_url and raw_db_url.startswith("postgres://"):
    DB_URL = raw_db_url.replace("postgres://", "postgresql://", 1)
else:
    DB_URL = raw_db_url

GEMINI_KEY = os.environ.get("GEMINI_API_KEY")
genai.configure(api_key=GEMINI_KEY)

# --- DATABASE CONNECTION ---
def get_db_connection():
    return psycopg2.connect(DB_URL)

# --- SMART GENERATION (WITH FAIL-SAFE FALLBACK) ---
def generate_smart_content(prompt_text, image_data=None, mime_type=None):
    
    # Define the System Persona
    system_instruction = """
    ROLE: You are 'Reality Circuit', a high-level Strategic Innovation Partner.
    MISSION:
    1. Help the user BRAINSTORM innovative ideas.
    2. Act as a "Second Brain" to clarify complex thoughts.
    3. If user asks about Real Estate: Switch to "Expert Consultant" mode (Analysis, Risks, ROI).
    TONE: Professional, military-strategic, concise ("War Room" style).
    LANGUAGE: Fluent in English and Telugu. Answer in the language asked.
    """

    # Helper function to prepare content parts
    def prepare_content(text, img=None, mime=None):
        if img:
            return [system_instruction + "\n\nUSER QUERY: " + text, {"mime_type": mime, "data": img}]
        return system_instruction + "\n\n" + text

    # --- ATTEMPT 1: USE GEMINI 2.0 (The Genius) ---
    try:
        model_primary = genai.GenerativeModel('gemini-2.0-flash-exp')
        content = prepare_content(prompt_text, image_data, mime_type)
        
        response = model_primary.generate_content(content)
        return response.text.strip() + "\n\n*[Generated by Gemini 2.0]*"

    except Exception as e:
        print(f"⚠️ Primary Model Failed ({str(e)}). Switching to Backup...")

        # --- ATTEMPT 2: USE GEMINI 1.5 (The Workhorse) ---
        try:
            model_backup = genai.GenerativeModel('gemini-1.5-flash')
            content = prepare_content(prompt_text, image_data, mime_type)
            
            response = model_backup.generate_content(content)
            return response.text.strip() + "\n\n*[Generated by Gemini 1.5]*"
            
        except Exception as e2:
            return f"STRATEGIC FAILURE: Both Intelligence Cores Offline. ({str(e2)})"

# --- ROUTES ---

@app.route('/')
def home():
    return "WAR ROOM HQ ONLINE. SYSTEMS NOMINAL."

@app.route('/api/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password') # In real app, hash this!

    if not username or not password:
        return jsonify({"error": "Missing Credentials"}), 400

    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    
    # Check if user exists
    cur.execute("SELECT * FROM users WHERE username = %s", (username,))
    user = cur.fetchone()
    
    if user and user['password'] == password:
        # Success!
        cur.close()
        conn.close()
        return jsonify({"username": username, "room_id": user['room_id']})
    else:
        cur.close()
        conn.close()
        return jsonify({"error": "Invalid Credentials"}), 401

@app.route('/api/signup', methods=['POST'])
def signup():
    data = request.json
    username = data.get('username')
    password = data.get('password')

    conn = get_db_connection()
    cur = conn.cursor()
    
    # Generate a unique Room ID based on username
    room_id = username.split('@')[0]
    
    try:
        cur.execute("INSERT INTO users (username, password, room_id) VALUES (%s, %s, %s)", (username, password, room_id))
        conn.commit()
        cur.close()
        conn.close()
        return jsonify({"username": username, "room_id": room_id})
    except Exception as e:
        cur.close()
        conn.close()
        return jsonify({"error": "User already exists"}), 400

@app.route('/api/chat/history', methods=['GET'])
def get_history():
    room_id = request.args.get('room_id')
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    cur.execute("SELECT * FROM room_chats WHERE room_id = %s ORDER BY timestamp ASC", (room_id,))
    messages = cur.fetchall()
    cur.close()
    conn.close()
    return jsonify(messages)

@app.route('/api/chat/clear', methods=['POST'])
def clear_history():
    data = request.json
    room_id = data.get('room_id')
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("DELETE FROM room_chats WHERE room_id = %s", (room_id,))
    conn.commit()
    cur.close()
    conn.close()
    return jsonify({"status": "CLEARED"})

@app.route('/api/chat/send', methods=['POST'])
def send_chat():
    data = request.json
    room_id = data.get('room_id')
    sender_name = data.get('sender_name')
    message_text = data.get('message', '')
    file_data = data.get('file_data')
    mime_type = data.get('mime_type')

    # 1. Store User Message
    if sender_name not in ["SYSTEM_COMMAND", "SYSTEM_WELCOME"]:
        display_text = message_text
        if file_data:
            display_text = f"[ATTACHMENT ANALYZED] {message_text}"
            
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("INSERT INTO room_chats (room_id, sender_name, message, is_ai) VALUES (%s, %s, %s, %s)", (room_id, sender_name, display_text, False))
        conn.commit()
        cur.close()
        conn.close()

    # 2. Logic: Should AI Reply?
    should_reply = False
    ai_prompt = ""
    
    if file_data:
        should_reply = True
        ai_prompt = f"Analyze this image attachment. User Note: {message_text}"
    elif sender_name == "SYSTEM_WELCOME":
        should_reply = True
        ai_prompt = f"The user '{message_text}' has entered. Welcome them to the War Room."
    else:
        # Check triggers
        triggers = ["@ai", "idea", "brainstorm", "risk", "roi", "analyze", "strategy"]
        is_addressed = any(t in message_text.lower() for t in triggers)
        should_reply = True # Aggressive reply mode for demo

        if is_addressed or should_reply:
             # Fetch Context
            conn = get_db_connection()
            cur = conn.cursor(cursor_factory=RealDictCursor)
            cur.execute("SELECT * FROM room_chats WHERE room_id = %s ORDER BY timestamp ASC LIMIT 10", (room_id,))
            rows = cur.fetchall()
            context_str = "\n".join([f"{r['sender_name']}: {r['message']}" for r in rows])
            cur.close()
            conn.close()
            ai_prompt = f"Context:\n{context_str}\n\nUser Query: {message_text}"

    if not should_reply:
        return jsonify({"status": "Stored (Silent Mode)"})

    # 3. Generate Reply
    try:
        ai_reply = generate_smart_content(ai_prompt, file_data, mime_type)
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("INSERT INTO room_chats (room_id, sender_name, message, is_ai) VALUES (%s, %s, %s, %s)", (room_id, "Reality Circuit", ai_reply, True))
        conn.commit()
        cur.close()
        conn.close()
        return jsonify({"ai_reply": ai_reply})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)